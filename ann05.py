# -*- coding: utf-8 -*-
"""ann05.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GUZGfkSIUGgLnsVDbcbQxF-lqpOLEZqM
"""

import numpy as np
import matplotlib.pyplot as plt

# Generate random data points
np.random.seed(0)
num_samples = 10
X = np.random.rand(num_samples, 2)  # Random points in 2D space
y = np.where(X[:, 1] > X[:, 0] + 0.3, 1, 0) # Assign classes based on position relative to line

# Define perceptron learning rule
def perceptron_learning_rule(X, y, learning_rate=0.1, epochs=100):
    num_samples, num_features = X.shape
    weights = np.zeros(num_features)
    bias = 0
    for epoch in range(epochs):
        for i in range(num_samples):
            prediction = predict_perceptron(X[i], weights, bias)
            error = y[i] - prediction
            weights += learning_rate * error * X[i]
            bias += learning_rate * error
    return weights, bias

# Prediction function of the perceptron
def predict_perceptron(x, weights, bias):
    linear_combination = np.dot(weights, x) + bias
    return 1 if linear_combination >= 0 else 0

# Train the perceptron
weights, bias = perceptron_learning_rule(X, y)

# Plot decision boundary
x_values = np.linspace(0, 1, 10)
y_values = -(weights[0] * x_values + bias) / weights[1]

plt.figure(figsize=(5, 6))
plt.scatter(X[:, 0], X[:, 1], c=y,label='Data Points')
plt.plot(x_values, y_values, 'r-', label='Decision Boundary')
plt.xlabel('Feature 1')
plt.ylabel('Feature 2')
plt.title('Perceptron Decision Boundary')
plt.legend()
plt.grid(True)
plt.show()

